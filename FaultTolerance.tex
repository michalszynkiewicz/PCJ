\documentclass[12pt]{article}
\usepackage[utf8]{inputenc}


\linespread{1.05}

\begin{document}


\title{Fault Tolerance for PCJ}

\author{Micha≈Ç Szynkiewicz}
\date{2015}
\maketitle
% mstodo: make it more a fairy-tale ;)

\section{Motivation}

Distributed computations are run on lots of nodes and often take large amount of time.
Having a 24 hour long computation on 1000 nodes means almost 3 years computations.

Hence, it is practical to make a parallel computing library fault tolerant.

\section{Dictionary}
\begin{itemize}
\item \textbf{PCJ library} - a library for Java language that helps to perform parallel and distributed calculations, able to work over ethernet or infiniband providing users with the uniform view across nodes.

\item \textbf{node} - a physical machine that takes a part in computations.

\item \textbf{node 0} - distinguished node. This paper assumes it doesn't fail.

\item \textbf{thread} - the smalles unit of computation. Realized by single java thread.
\end{itemize}

\section{Concepts}
Currently we assume that there is a special node, namely \textit{node 0}, that never dies.
We plan to provide two fault tolerance strategies: ignoring node failure and respawning failed threads.
  \\
Moreover we plan to provide a resilient storage to make it possible to restore thread state from a snapshot.
Resilient storage will have two modes: synchronous and asynchronous.
Synchronous mode will allow programs to recover from the latest position achieved by the failed thread.
In asynchronous mode state will be saved in a storage in a non-blocking fashion.
\\
                \\
%                mstodo: move descriptions elsewhere
\section{Example use cases of strategies}
Following are examples of possible usages of fault tolerance strategies described in this paper.
\subsection{Ignore failure}
The failed node is ignored, all of its' data is lost.
Might be used for instance for monte carlo randomized algorithms, e.g. monte carlo Pi approxmiation.
\subsection{Respawn node with synchronous resilient storage}
The most powerful strategy. Upon failure of physical node all the threads running on it are recreated on other nodes.
Then the state of threads is recreated from the latest saved state.
Might be used for example for parallel FFT implementation.
In FFT implementation, in multiple phases, each thread first makes computations and then broadcasts the results.
It is crucial to remember the exact state from the broadcasting phase.
% mstodo: verify
\subsection{Respawn node with asynchronous resilient storage}
As in previous strategy, threads are recreated on active nodes.
The state is restored from resilient storage, but since the storage is asynchronous, it might contain old data.

\section{API}

\subsection{Impact on API}

\section{Node failure handling implementation}

The main elements of implementation are: monitoring nodes for failure and adjusting configuration after node failure.

\subsection{Node monitoring}
Monitoring works in two ways::
\begin{itemize}
\item The immortal \textit{node 0} is monitoring other nodes by sending PING message and waiting for PONG.
If, for some node, sending PING fails, or the node does not answer with PONG for a long (configurable) time,
it is assumed failed.
\item
If \textit{node A} encounters a communication error when trying to communicate with \textit{node B}
(e.g. if updating a variable value on \textit{node B} fails), \textit{node A} informs \textit{node 0} that \textit{node B} has failed.

\end{itemize}

\subsection{Reconfiguration}
On node failure \textit{node 0} sends a proper reconfiguration message to all nodes.
Depending on the type of selected strategy there are two...

\section{Resilient storage implementation}

\section{Current status}
Currently no-resilient-storage, Ignore policy is being implemented.

\section{Performance overhead}

\section{Summary}

\end{document}
